#!/usr/bin/ruby1.8
# UGLY!!

require '../checker/erno.rb'

class Cube
	def from_i(x)
		1.upto(48) do |i|
			@state[i] = x % 48 + 1
			x /= 48
		end
	self
	end
end

def hash(m)
	c = Cube.new
	if m.length >= 1
		m = [*1..m.length].inject(0){ |r,i| r + (m[i-1] * 256**(i-1)) }
		while m != 0
			c.apply([m%6])
			m /= 6
		end
	end
	c
end

moves = ['U', 'L', 'F', 'R', 'B', 'D']

unless ARGV.length == 1
	puts "Usage: #{$0} <hash>"
	exit
end

h = ARGV[0]
z = Cube.new.from_i(h.to_i(16))
puts "hash: #{z.to_i.to_s(16)}"
puts "hash cube: #{z.to_s}"

gap = File.popen("gap -q cube.gap", "a+")
gap.puts "Print(PreImagesRepresentative(repr, PermList(#{z})));"
gap.close_write
res = gap.readlines
gap.close

res = res.map{ |l| l.chomp }.join("").split("*")
puts "preimage move: #{res.join(" ").gsub("^-1", "'").gsub("^-2", "2").gsub("^2", "2").gsub("^3","'").gsub("^-3", "")}"

res = res.map{ |m|
	if m[1..-1] == "^2" or m[1..-1] == "^-2"
		[ m[0,1] ] * 2
	elsif m[1..-1] == "^-1" or m[1..-1] == "^3"
		[ m[0,1] ] * 3
	else
		[ m[0,1] ]
	end
}

res = res.flatten.map{ |m| moves.index(m) }.reverse

### DIRTY UGLY HACK
# (representation is not allowed to contain leading zeros)
res += [1,1,1,1] if res.last == 0
###

x = ""

res2 = [*0..(res.length-1)].inject(0){ |r,i| r + (res[i] * (6**i)) }
r = []
while res2 != 0
	r << (res2 % 256)
	res2 /= 256
end
x = r.pack("C*")

hx = hash(x)
if hx.to_i.to_s(16) != z.to_i.to_s(16)
	puts
	puts "ERROR. Something went wrong."
	puts hx.to_i.to_s(16)
	puts
	exit
end

puts "preimage bin: " + x.unpack("C*").map{ |i| "%02x" % i }.join
